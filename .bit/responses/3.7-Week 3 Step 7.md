---
files: n/a
stepType: checks
scripts: test.3.7.js
week: 3
step: 7
name: Leaky secrets
---

Week 3 Step 7 ‚¨§‚¨§‚¨§‚¨§‚¨§‚¨§‚¨§‚óØ‚óØ | üïê Estimated completion: 10-20 minutes

## Your time's up....
*This week, you will be going through steps to store a message from Twilio in CosmosDB and return the most recent message.*

### ‚úÖ  Task:

- [ ]  Make sure you're on the `week3` branch
- [ ]  Take a message from a POST request's parameters from Twilio
- [ ]  Store the message in CosmosDB
- [ ]  Return the most recent message

### Install @azure/cosmos

Before we do anything else, we should install the `npm` package `@azure/cosmos`. 

<details>
<summary>:question: How do I install an `npm` package?</summary>
</br>

Click on the "Console" tab in the left panel under "Development Tools".

![https://user-images.githubusercontent.com/69332964/99189070-59e31d00-272d-11eb-80a4-17444e5fac65.png](https://user-images.githubusercontent.com/69332964/99189070-59e31d00-272d-11eb-80a4-17444e5fac65.png)

Inside the console (shown on the right panel), type in the following command:

[`npm install @azure/cosmos`](https://www.npmjs.com/package/@azure/cosmos) <br />

</details>

After you've finished installing `@azure/cosmos`, go back to the Code + Test tab - we're ready to start coding!

### Configuration

First, we need to instantiate a variable `CosmosClient` from the `@azure/cosmos` package we just downloaded. 

<details>
<summary>:question: How do I create my CosmosClient?</summary>

```js
const CosmosClient = require("@azure/cosmos").CosmosClient;
```

</details>

Then, we'll want to write down our config object, which will contain all of the sensitive information that we need to manipulate our data. Your object should be called `config`, which keys for `endpoint`, `key`, `databaseId`, `containerId`, and `partitionKey`.

<details>
<summary>:question: What should my config object look like?</summary>

Here is an example of the config object. Make sure your databaseId, containerId, and partitionKey are correct.

```js
const config = {
  endpoint: process.env.ENDPOINT,
  key: process.env.KEY,
  databaseId: "SecretStorer",
  containerId: "secrets",
  partitionKey: {kind: "Hash", paths: ["/secrets"]}
};
```

</details>

### The `create` Function

Now, we want to write an asynchronous `create` function that takes in the parameter of `client` (this will be our `CosmosClient`). 

This function will:

1. Use the client to create a database with an id of `config.databaseId` if it does not exist.
2. Use the client to create a container *inside* the database of ID `config.databaseId`. This container will have an ID of `config.containerId` and a key of `config.partitionKey`.

<details>
<summary>:question: How do I create a database in code?</summary>

```js
const { database } = await client.databases.createIfNotExists({
    id: config.databaseId
});
```

</details>


<details>
<summary>:question: How do I create a container in my database?</summary>

```js
const { container } = await client
    .database(config.databaseId)
    .containers.createIfNotExists(
        { id: config.containerId, key: config.partitionKey },
        { offerThroughput: 400 }
);
```

</details>

### The `createDocument` Function

Next, we need to create another asynchronous function called `createDocument` that will take in a parameter of `newItem`. As given from the function signature, this function will create a new document within the database container that contains the newItem data.

In its entirety, the function will:

1. Use the global `config` object to create the database and container if they do not exist. (Hint: this uses the `create` function we just implemented!)
2. Create a query that uses SQL language to fetch the most recent data document.
3. Read all items within the Items container.
4. Return all of the items.



### The Main Function



```js
const querystring = require('querystring');
// npm install @azure/cosmos

async function createDocument(newItem) {
    var { endpoint, key, databaseId, containerId } = config;
    const client = new CosmosClient({endpoint, key});
    const database = client.database(databaseId);
    const container = database.container(containerId);
    await create(client, databaseId, containerId);

    const querySpec = {
        query: "SELECT top 1 * FROM c order by c._ts desc"
    };

// read all items in the Items container
    const { resources: items } = await container.items
        .query(querySpec)
        .fetchAll();

    const {resource: createdItem} = await container.items.create(newItem);
    return items
}

module.exports = async function (context, req) {
    context.log('JavaScript HTTP trigger function processed a request.');

    const queryObject = querystring.parse(req.body);
    message = queryObject.Body;
    let document = {"message":message}

    let items = await createDocument(document)
    context.log(items)

    const responseMessage = `Thanks üòä! Stored your secret "${message}". üòØ Someone confessed that: ${JSON.stringify(items[0].message)}`

    context.res = {
        // status: 200, /* Defaults to 200 */
        body: responseMessage
    };
}

// https://www.twilio.com/docs/sms/quickstart/node
// https://www.neilwithdata.com/azure-functions-post-body-js

```

### Test Your Work

To test your work, use Postman to send a POST request *without* an image attached. You should see a response similar to the below:

```JSON
{
  "body" : "Sorry! No image attached."
}
```
> üí° Yay! This means the error was successfully caught.